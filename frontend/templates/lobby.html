{{define "lobby-page"}}
<!DOCTYPE html>
<html lang="{{.Locale}}">

<head>
    <title>Gueswhat - Game</title>
    <meta charset="UTF-8" />
    {{template "font-decl" .}}

    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="{{.RootPath}}/resources/bootstrap.min.css">
    <link rel="stylesheet" href="{{.RootPath}}/resources/fontawesome.min.css">
    <link rel="stylesheet" type="text/css" href="{{.RootPath}}/resources/color.css">

    <link rel="stylesheet" type="text/css" href="{{.RootPath}}/resources/base.css">
    <link rel="stylesheet" type="text/css" href="{{.RootPath}}/resources/lobby.css">

    <link rel="icon" type="image/png" href="{{.RootPath}}/resources/favicon.png" />

</head>

<body>
    <div class="container-fluid" id="lobby">
        <noscript><span class="noscript">{{.Translation.Get "requires-js"}}</span></noscript>


        <div class="row p-4" id="lobby-header">

            <div class="col-6 col-md-3 mb-3 order-title text-center my-auto text-white">

                <a href="{{.RootPath}}/" class="link-to-home">
                    <h2 style="text-shadow: 4px 4px #000000;" class="my-text-left font-one">GUESSWHAT</h2>
                </a>

            </div>

            <div class="col-12 col-md-6 mb-3 text-center order-word mx-auto text-white" id="lobby-header-center-element">

                <h4 id="word-container" class="font-one"></h4>

            </div>

            <div class="col-6 col-md-3 mb-3 order-rounds text-white">

                <div class="row">
                    <div class="col-7 font-one">
                        <h4 class="my-2 my-text-right"><span id="rounds-heading">{{.Translation.Get "round"}}&nbsp;</span>
                            <span id="rounds"></span> /
                            <span id="max-rounds"></span>
                        </h4>
                    </div>
                    <div class="col-5 font-one">
                        <div id="time-left" class="p-2 fw-bolder text-center">
                            <h5 id="time-left-value">âˆž</h5>
                        </div>
                    </div>
                </div>

            </div>


            <div class="col-12 col-md-3 order-leaderoard mb-5 bg-white my-small-font p-0 font-one" id="leaderboard">

            </div>

            <div class="col-12 col-md-6 order-canvas mb-5">

                <div id="drawing-board-wrapper" style="border: solid 4px black; border-bottom:none;">
                    <div id="drawing-board-inner-wrapper">
                        <canvas id="drawing-board"></canvas>

                        <div id="center-dialogs">

                            <div id="word-dialog" class="center-dialog p-4">

                                <h4 class="text-center">{{.Translation.Get "choose-a-word"}}</h4>
                                <br>
                                <div class="row">
                                    <div class="col-12 text-center p-0 w-100">
                                        <button id="word-button-zero" class="btn btn-word text-uppercase" onclick="chooseWord(0)" style="margin-right: 5px; margin-bottom: 5px;"></button>
                                        <button id="word-button-one" class="btn btn-word text-uppercase" onclick="chooseWord(1)" style="margin-right: 5px; margin-bottom: 5px;"></button>
                                        <button id="word-button-two" class="btn btn-word text-uppercase" onclick="chooseWord(2)"></button>
                                    </div>
                                </div>

                            </div>

                            <div id="start-dialog" class="center-dialog p-4">
                                <h4 class="text-center">{{.Translation.Get "start-the-game"}}</h4>

                                <div class="input-group mb-3">
                                    <div class="input-group-prepend">
                                        <span class="input-group-text" id="basic-addon1">{{.Translation.Get "change-your-name"}}:</span>
                                    </div>
                                    <input type="text" class="form-control" placeholder="Username" aria-label="Username" aria-describedby="basic-addon1" id="namechange-field-start-dialog">
                                </div>

                                <div class="row">
                                    <div class="col-sm-12 text-center">
                                        <button class="btn btn-outline-dark" onclick="changeName(document.getElementById('namechange-field-start-dialog').value)">{{.Translation.Get "apply"}}</button>

                                        <button class="btn btn-info" onclick="startGame()">{{.Translation.Get "start"}}</button>
                                    </div>
                                </div>

                            </div>

                            <div id="unstarted-dialog" class="center-dialog p-4">

                                <h4 class="text-center">{{.Translation.Get "game-not-started-title"}}</h4>

                                <h6 class="text-center">{{.Translation.Get "waiting-for-host-to-start"}}</h6>

                                <div class="input-group mb-3">
                                    <div class="input-group-prepend">
                                        <span class="input-group-text" id="basic-addon1">{{.Translation.Get "change-your-name"}}:</span>
                                    </div>
                                    <input type="text" class="form-control" placeholder="Username" aria-label="Username" aria-describedby="basic-addon1" id="namechange-field-unstarted-dialog">
                                </div>

                                <div class="row">
                                    <div class="col-sm-12 text-center">
                                        <button class="btn btn-outline-dark" onclick="changeName(document.getElementById('namechange-field-unstarted-dialog').value)">{{.Translation.Get "apply"}}</button>
                                    </div>
                                </div>

                            </div>

                            <div id="waitchoose-dialog" class="center-dialog p-4">

                                <h4 class="text-center mb-4">{{.Translation.Get "waiting-for-word-selection"}}</h4>

                                <h6 class="text-center"><span id="waitchoose-drawer"></span> {{.Translation.Get "is-choosing-word"}}</h6>

                            </div>


                            <div class="modal fade" id="namechange-dialog" data-bs-backdrop="false" data-bs-keyboard="false" tabindex="-1" aria-labelledby="staticBackdropLabel" aria-hidden="true">
                                <div class="modal-dialog">
                                    <div class="modal-content">
                                        <div class="modal-header">
                                            <h5 class="modal-title" id="staticBackdropLabel">{{.Translation.Get "change-your-name"}}</h5>
                                            <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                                        </div>
                                        <div class="modal-body">
                                            <div id="carouselExampleControls" class="carousel slide text-center mb-4" data-interval="false">

                                                <!-- Wrapper for slides -->
                                                <div class="carousel-inner">
                                                    <div class="carousel-item active">
                                                        <img src="{{.RootPath}}/resources/character1.png" alt="Character" class="my-img-fluid">
                                                    </div>

                                                    <div class="carousel-item ">
                                                        <img src="{{.RootPath}}/resources/character2.png" alt="Character" class="my-img-fluid">
                                                    </div>

                                                    <div class="carousel-item ">
                                                        <img src="{{.RootPath}}/resources/character3.png" alt="Character" class="my-img-fluid">
                                                    </div>

                                                    <div class="carousel-item ">
                                                        <img src="{{.RootPath}}/resources/character4.png" alt="Character" class="my-img-fluid">
                                                    </div>

                                                    <div class="carousel-item ">
                                                        <img src="{{.RootPath}}/resources/character5.png" alt="Character" class="my-img-fluid">
                                                    </div>
                                                </div>

                                                <!-- Left and right controls -->
                                                <button class="carousel-control-prev" type="button" data-bs-target="#carouselExampleControls" data-bs-slide="prev" style="filter: invert(100%);">
                                                    <span class="carousel-control-prev-icon" aria-hidden="true"></span>
                                                    <span class="visually-hidden">Previous</span>
                                                </button>
                                                <button class="carousel-control-next" type="button" data-bs-target="#carouselExampleControls" data-bs-slide="next" style="filter: invert(100%);">
                                                    <span class="carousel-control-next-icon" aria-hidden="true"></span>
                                                    <span class="visually-hidden">Next</span>
                                                </button>

                                                <input name="activeimage" id="activeimage" value="/resources/character1.png" hidden>

                                            </div>
                                            <div class="input-group mb-3">
                                                <input type="text" class="form-control" placeholder="Username" aria-label="Username" aria-describedby="basic-addon1" id="namechange-field">
                                            </div>
                                        </div>
                                        <div class="modal-footer">
                                            <button class="btn btn-outline-dark" data-bs-dismiss="modal">{{.Translation.Get "close"}}</button>
                                            <button class="btn btn-info" onclick="changeName(document.getElementById('namechange-field').value, document.getElementById('activeimage').value)" data-bs-dismiss="modal">{{.Translation.Get "save"}}</button>

                                        </div>
                                    </div>
                                </div>
                            </div>


                            <div id="game-over-dialog" class="center-dialog p-3">
                                <h4 id="game-over-dialog-title" class="text-center mb-3">Result</h4>

                                <div id="game-over-scoreboard"></div>

                                <div class="row mt-3">
                                    <div class="col-sm-12 text-center">
                                        <button id="restart-button" class="btn btn-outline-dark" onclick="startGame()">Restart</button>
                                    </div>
                                </div>

                            </div>

                            <div id="kick-dialog" class="center-dialog p-4">
                                <h4 class="text-center">{{.Translation.Get "votekick-a-player"}}</h4>

                                <div id="kick-dialog-players"></div>

                                <div class="row mt-3">
                                    <div class="col-sm-12 text-center">
                                        <button class="btn btn-outline-dark" onclick="hideKickDialog()">{{.Translation.Get "close"}}</button>

                                    </div>
                                </div>

                            </div>
                        </div>
                    </div>
                </div>

                <div id="toolbox-container" class="bg-white" style="border: solid 4px black; border-top:none;">

                    <div id="toolbox">
                        <div id="color-picker-component" class="colorpicker-component mr-2 p-2">
                            <input id="color-picker" value="#38a677" onchange="setColorFromColorPicker()" value="#000000" alt="{{.Translation.Get "change-active-color"}}" title="{{.Translation.Get "change-active-color"}}" hidden>
                            <span class="input-group-addon color-picker"><i></i></span>
                        </div>

                        <label for="tool-type-pencil">
                            <input id="tool-type-pencil" class="custom-check-or-radio line-width-button" onchange="chooseTool(pen)" type="radio" name="tool-type" checked>
                            <div onmousedown="document.getElementById('tool-type-pencil').click()" onmouseup="document.getElementById('tool-type-pencil').click()" class="line-width-button-content">
                                <span title="{{.Translation.Get "use-pencil"}}" alt="{{.Translation.Get "use-pencil"}}" id="tool-type-pencil-button"><i class="fa fa-pencil"></i></span>
                            </div>
                        </label>
                        <label for="tool-type-fill">
                            <input id="tool-type-fill" class="custom-check-or-radio line-width-button" onchange="chooseTool(fillBucket)" type="radio" name="tool-type">
                            <div onmousedown="document.getElementById('tool-type-fill').click()" onmouseup="document.getElementById('tool-type-fill').click()" class="line-width-button-content">
                                <span title="{{.Translation.Get "use-pencil"}}" alt="{{.Translation.Get "use-pencil"}}" id="tool-type-fill-button"><i class="fas fa-fill-drip"></i></span>
                            </div>
                        </label>
                        <label for="tool-type-rubber">
                            <input id="tool-type-rubber" class="custom-check-or-radio line-width-button" onchange="chooseTool(rubber)" type="radio" name="tool-type">
                            <div onmousedown="document.getElementById('tool-type-rubber').click()" onmouseup="document.getElementById('tool-type-rubber').click()" class="line-width-button-content">
                                <span title="{{.Translation.Get "use-eraser"}}" alt="{{.Translation.Get "use-eraser"}}" id="tool-type-rubber-button"><i class="fas fa-eraser"></i></span>
                            </div>
                        </label>

                        <div id="tool-type-redo" onclick="clearCanvasAndSendEvent()" alt="{{.Translation.Get "clear-canvas"}}" title="{{.Translation.Get "clear-canvas"}}">
                            <span><i class="fas fa-redo"></i></span>
                        </div>
                    </div>

                </div>
            </div>

            <div class="col-12 col-md-3 order-chat mb-5 bg-white position-relative font-one" id="chat" style="border: 4px solid black; min-height: 330px;">
                <div id="message-container" class="my-small-font mt-2"></div>
                <form class="mt-3 p-2 w-100 position-absolute bottom-0 start-0" onsubmit="return sendMessage()">
                    <input id="message-input" type="text" class="form-control my-small-font" autocomplete="off" placeholder="{{.Translation.Get "message-input-placeholder"}}" />
                </form>

            </div>


            <div class="col-6 mb-4 order-votekick font-one">
                <button class="btn btn-votekick" id="kick-button" style="display: none;" onclick="showKickDialog()" alt="{{.Translation.Get "votekick-a-player"}}" title="{{.Translation.Get "votekick-a-player"}}">Votekick</button>
            </div>
            <div class="col-5 order-sound">
                <button class="btn-sound" onclick="toggleSound()" alt="{{.Translation.Get "toggle-soundeffects"}}" title="{{.Translation.Get "toggle-soundeffects"}}"><i id="sound-toggle-label" class="fas fa-volume-up"></i></button>
            </div>
        </div>

        <div class="row p-4 font-one" id="invite-section">
            <div class="col-md-4 col-12 text-center my-auto">
                <h2>INVITE LINK</h2>
            </div>

            <div class="col-md-8 col-12 text-center">
                <div class="input-group my-3 copy-link-group">
                    <input type="text" class="form-control col-md-9 col-12" placeholder="Lobby link" value="https://www.guesswhat.com" id="lobylink" aria-describedby="copy-button">
                    <button class="btn text-white btn-success px-3 col-md-3 col-12" type="button" id="copy-button" data-clipboard-target="#lobylink">CLICK TO COPY</button>
                </div>
            </div>
        </div>


    </div>

    <script src="{{.RootPath}}/resources/jquery.min.js"></script>

    <script type="text/javascript" src="{{.RootPath}}/resources/bootstrap.bundle.min.js"></script>
    <script type="text/javascript" src="{{.RootPath}}/resources/clipboard.js"></script>
    <script type="text/javascript" src="{{.RootPath}}/resources/color.js"></script>
    <script type="text/javascript" src="{{.RootPath}}/resources/fontawesome.js"></script>
    <script type="text/javascript" src="{{.RootPath}}/resources/floodfill.js"></script>


    <script>
        $(document).ready(function() {
            $('#color-picker-component').colorpicker();

            $('#color-picker-component').colorpicker().on('changeColor',
                function(ev) {
                    setColorFromColorPicker();
                });

            var clipboard = new Clipboard('#copy-button');
            clipboard.on('success', function(e) {
                $(e.trigger).text("COPIED!");
                e.clearSelection();
                setTimeout(function() {
                    $(e.trigger).text("CLICK TO COPY");
                }, 2500);
            });
        });

    </script>

    <script type="text/javascript">
        let lobbylink = document.getElementById("lobylink");
        lobbylink.value = window.location.href;

    </script>

    <script type="text/javascript">
        var myCarousel = document.getElementById('carouselExampleControls');

        var testimg = document.getElementById("activeimage");

        myCarousel.addEventListener('slid.bs.carousel', function() {

            var activeSlide = document.getElementsByClassName("carousel-item active");

            var img = activeSlide[0].children[0];

            testimg.value = img.getAttribute("src");
        })

    </script>


    <script type="text/javascript">
        String.prototype.format = function() {
            return [...arguments].reduce((p, c) => p.replace(/%s/, c), this);
        };

        let socketIsConnecting = false;
        let hasSocketEverConnected = false;
        let socket;

        function connectToWebsocket() {
            if (socketIsConnecting === true) {
                return;
            }

            socketIsConnecting = true;

            if (location.protocol === "https:") {
                console.log("Attempting secure socket connection on port " + location.port + "...");
                socket = new WebSocket("wss://" + location.hostname + ":" + location.port + "{{.RootPath}}/v1/ws?lobby_id={{.LobbyID}}");
            } else {
                console.log("Attempting socket connection on port " + location.port + "...");
                socket = new WebSocket("ws://" + location.hostname + ":" + location.port + "{{.RootPath}}/v1/ws?lobby_id={{.LobbyID}}");
            }

            socket.onerror = error => {
                //Is not connected and we haven't yet said that we are done trying to
                //connect, this means that we could never even establish a connection.
                if (socket.readyState != 1 && !hasSocketEverConnected) {
                    socketIsConnecting = false;
                    showTextDialog("connection-error-dialog",
                        '{{.Translation.Get "error-connecting"}}',
                        '{{.Translation.Get "error-connecting-text"}}');
                    console.log("Error establishing connection: ", error);
                } else {
                    console.log("Socket error: ", error)
                }
            };

            socket.onopen = () => {
                closeDialog(reconnectDialogId);

                hasSocketEverConnected = true;
                socketIsConnecting = false;

                socket.onclose = event => {
                    //We want to avoid handling the error multiple times and showing the incorrect dialogs.
                    socket.onerror = null;

                    console.log("Socket Closed Connection: ", event);
                    console.log("Attempting to reestablish socket connection.");
                    showReconnectDialogIfNotShown();
                    connectToWebsocket();
                };

                registerMessageHandler(socket);

                console.log("Successfully Connected");
            };
        }

        const reconnectDialogId = "reconnect-dialog";

        function showReconnectDialogIfNotShown() {
            let previousReconnectDialog = document.getElementById(reconnectDialogId);

            //Since the content is constant, there's no need to ever show two.
            if (previousReconnectDialog === undefined || previousReconnectDialog === null) {
                showTextDialog(reconnectDialogId, '{{.Translation.Get "connection-lost"}}',
                    '{{.Translation.Get "connection-lost-text"}}');
            }
        }

        connectToWebsocket();

        //In order to avoid automatically canceling the socket connection, we keep
        //sending dummy events every 5 seconds. This was a problem on Heroku. If
        //a player took a very long time to choose a word, the connection of all
        //players could be killed and even cause the lobby being closed. Since
        //that's very frustrating, we want to avoid that.
        window.setInterval(() => {
            socket.send(JSON.stringify({
                type: "keep-alive"
            }));
        }, 5000);

        //Makes sure that the server notices that the player disconnects.
        //Otherwise a refresh (on chromium based browsers) can lead to the server
        //thinking that there's already an open tab with this lobby.
        window.onbeforeunload = () => {
            //Avoid unintentionally reestablishing connection.
            socket.onclose = null;
            socket.close();
        };

        const messageInput = document.getElementById("message-input");
        const playerContainer = document.getElementById("leaderboard");
        const wordContainer = document.getElementById("word-container");
        const chat = document.getElementById("chat");
        const messageContainer = document.getElementById("message-container");
        const roundSpan = document.getElementById("rounds");
        const maxRoundSpan = document.getElementById("max-rounds");
        const timeLeftValue = document.getElementById("time-left-value");
        const drawingBoard = document.getElementById("drawing-board");

        const toolbox = document.getElementById("toolbox");

        const colorPicker = document.getElementById("color-picker");

        const centerDialogs = document.getElementById("center-dialogs");

        const unstartedDialog = document.getElementById("unstarted-dialog");
        const waitChooseDialog = document.getElementById("waitchoose-dialog");
        const waitChooseDrawerSpan = document.getElementById("waitchoose-drawer");
        const namechangeDialog = document.getElementById("namechange-dialog");
        const namechangeFieldUnstartedDialog = document.getElementById("namechange-field-unstarted-dialog");
        const namechangeFieldStartDialog = document.getElementById("namechange-field-start-dialog");
        const namechangeField = document.getElementById("namechange-field");

        const kickButton = document.getElementById("kick-button");

        const startDialog = document.getElementById("start-dialog");
        const gameOverDialog = document.getElementById("game-over-dialog");
        const gameOverDialogTitle = document.getElementById("game-over-dialog-title");
        const gameOverScoreboard = document.getElementById("game-over-scoreboard");
        const restartButton = document.getElementById("restart-button");
        const wordDialog = document.getElementById("word-dialog");
        const wordButtonZero = document.getElementById("word-button-zero");
        const wordButtonOne = document.getElementById("word-button-one");
        const wordButtonTwo = document.getElementById("word-button-two");

        const kickDialog = document.getElementById("kick-dialog");
        const kickDialogPlayers = document.getElementById("kick-dialog-players");

        const soundToggleLabel = document.getElementById("sound-toggle-label");
        let sound = localStorage.getItem("sound") !== "false";
        updateSoundIcon();

        function showTextDialog(id, title, message) {
            let messageNode = document.createElement("span");
            messageNode.innerText = message;
            showDialog(id, title, messageNode);
        }

        function showDialog(id, title, contentNode) {
            let newDialog = document.createElement("div");
            newDialog.classList.add("center-dialog");
            newDialog.classList.add("p-4");

            if (id !== null && id !== "") {
                newDialog.id = id;
            }

            let dialogTitle = document.createElement("h4");
            dialogTitle.classList.add("text-center");
            dialogTitle.innerText = title;
            newDialog.appendChild(dialogTitle);

            let dialogContent = document.createElement("h6");
            dialogContent.classList.add("text-center");
            dialogContent.appendChild(contentNode);
            newDialog.appendChild(dialogContent);

            newDialog.style.visibility = "visible";
            centerDialogs.appendChild(newDialog);
        }

        function closeDialog(id) {
            const dialog = document.getElementById(id);
            if (dialog !== undefined && dialog !== null) {
                const parent = dialog.parentElement;
                if (parent !== undefined && parent !== null) {
                    parent.removeChild(dialog);
                }
            }
        }

        function showKickDialog() {
            if (votekickEnabled !== true) {
                //Should never show, as this method should never be called anyways.
                //Anyways, in case of a bug or forcefully calling this, we still
                //intend to inform the user.
                alert("Votekicking isn't enabled in this lobby.");
                return;
            }

            if (cachedPlayers && cachedPlayers) {
                kickDialogPlayers.innerHTML = "";

                cachedPlayers.forEach(player => {
                    //Don't wanna allow kicking ourselves.
                    if (player.id !== ownID && player.connected) {
                        let playerKickEntry = document.createElement("button");
                        playerKickEntry.classList.add("kick-player-button");
                        playerKickEntry.onclick = () => onVotekickPlayer(player.id);
                        playerKickEntry.innerText = player.name;
                        kickDialogPlayers.appendChild(playerKickEntry);
                    }
                });

                kickDialog.style.visibility = "visible";
            }
        }

        function hideKickDialog() {
            kickDialog.style.visibility = "hidden";
        }

        function changeName(name, img) {
            //Avoid unnecessary traffic.

            socket.send(JSON.stringify({
                type: "name-change",
                data: name + ";" + img,
            }));

        }

        function setUsernameLocally(name) {
            ownName = name;
            namechangeFieldUnstartedDialog.value = name;
            namechangeFieldStartDialog.value = name;
            namechangeField.value = name;
        }

        function toggleSound() {
            sound = !sound;
            localStorage.setItem("sound", sound.toString());
            updateSoundIcon();
        }

        function updateSoundIcon() {
            if (sound) {
                soundToggleLabel.classList.remove("fa-volume-mute");
                soundToggleLabel.classList.add("fa-volume-up");
            } else {
                soundToggleLabel.classList.add("fa-volume-mute");
                soundToggleLabel.classList.remove("fa-volume-up");
            }
        }

        //The drawing board has a base size. This base size results in a certain ratio
        //that the actual canvas has to be resized accordingly too. This is needed
        //since not every client has the same screensize.
        let baseWidth = parseInt("{{.DrawingBoardBaseWidth}}");
        let baseHeight = parseInt("{{.DrawingBoardBaseHeight}}");
        let boardRatio = baseWidth / baseHeight;

        // Moving this here to extract the context after resizing
        const context = drawingBoard.getContext("2d");

        function scaleUpFactor() {
            return baseWidth / drawingBoard.clientWidth;
        }

        //scalesUp the value using scaleUpFactor and reduces the precision.
        //This makes sense since we absolutely don't need the precision and
        //we'll reduce network traffic this way.
        function scaelUpAndPrepareFloatForServer(value) {
            //We reduce the precision in multiple steps, since we get a string
            //as an intermediate result. The reason we don't want a string, is
            //that unmarshalling on the backend won't work with strings for float
            //values, unless explicitly specified, which however will cause it
            //not to work without quotes. Example:
            //  123.213476124918724 -> "123.21" -> 123.21
            return parseFloat((scaleUpFactor() * value).toFixed(2));
        }

        function scaleDownFactor() {
            return drawingBoard.clientWidth / baseWidth;
        }

        const pen = 0;
        const rubber = 1;
        const fillBucket = 2;

        let allowDrawing = false;

        //Initially, we require some values to avoid running into nullpointers
        //or undefined errors. The specific values don't really matter.
        let localTool = pen;
        let localLineWidth = 8;
        let localLineWidthUnscaled = 8;

        let toolButtonPen = document.getElementById("tool-type-pencil");
        let toolButtonRubber = document.getElementById("tool-type-rubber");
        let toolButtonFill = document.getElementById("tool-type-fill");

        //We use the states present in UI elements, since in case of
        //hitting F5(Refresh), the browser will not reset these states to the
        //initial values defined in the HTML.
        //The necessary cursor update implicitly happens with setLineWidth.
        let localColor = hexStringToRgbColorObject(colorPicker.value);


        if (toolButtonPen.checked) {
            chooseTool(pen);
        } else if (toolButtonFill.checked) {
            chooseTool(fillBucket);
        } else if (toolButtonRubber.checked) {
            chooseTool(rubber);
        }

        function setColorFromColorPicker() {
            setColorWithoutUpdatingColorPicker(colorPicker.value);
        }

        function setColor(color) {
            colorPicker.value = color;
            setColorWithoutUpdatingColorPicker(color);
        }

        function setColorWithoutUpdatingColorPicker(color) {
            localColor = hexStringToRgbColorObject(color);

            if (localTool === rubber) {
                //Hack to correct selection. Doesn't automatically trigger chooseTool(pen).
                toolButtonPen.click();
                chooseTool(pen);
                //Cursor update is implicit.
            } else {
                updateCursor();
            }
        }

        function setLineWidth(value) {
            localLineWidthUnscaled = value;
            localLineWidth = value * scaleDownFactor();
            updateCursor();
        }

        function chooseTool(value) {
            if (value === pen || value === rubber || value === fillBucket) {
                localTool = value;
            } else {
                //If this ends up with an invalid value, we use the pencil.
                localTool = pen;
            }
            updateCursor();
        }

        //We accept both #RRGGBB and RRGGBB. Both are treated case insensitive.
        function hexStringToRgbColorObject(hexString) {
            const hexColorsRegex = /#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})/i;
            const match = hexString.match(hexColorsRegex)
            return {
                r: parseInt(match[1], 16),
                g: parseInt(match[2], 16),
                b: parseInt(match[3], 16)
            };
        }

        function rgbColorObjectToHexString(color) {
            return "#" +
                numberTo16BitHexadecimal(color.r) +
                numberTo16BitHexadecimal(color.g) +
                numberTo16BitHexadecimal(color.b);
        }

        function numberTo16BitHexadecimal(number) {
            return Number(number).toString(16).padStart(2, "0");
        }

        const rubberColor = {
            r: 255,
            g: 255,
            b: 255
        };

        function updateCursor() {
            if (allowDrawing) {

                toolbox.style.visibility = "visible";

                if (localTool === rubber) {
                    setCircleCursor(rubberColor, localLineWidth);
                } else if (localTool === fillBucket) {
                    const outerColor = getComplementaryCursorColor(localColor);
                    drawingBoard.style.cursor = `url('data:image/svg+xml;utf8,` +
                        encodeURIComponent(
                            `<svg xmlns="http://www.w3.org/2000/svg" version="1.1" height="32" width="32">` +
                            generateSVGCircle(8, localColor, outerColor) +
                            `<path d="M8.583 22.081a4.913 5.083 0 0 0 1.449-3.618 4.437 4.59 0 0 1 4.433-4.585h2.022a.391.404 0 0 1 .276.69l-1.547 1.6a.391.404 0 0 0 0 .572l3.299 3.412a.391.404 0 0 1 .115.286v1.323a.977 1.011 0 0 1-.977 1.011.195.202 0 0 0-.195.202V25.4a1.368 1.415 0 0 1-2.736 0v-.606a.391.404 0 0 0-.782 0v2.628a1.368 1.415 0 0 1-2.736 0v-1.415a.391.404 0 0 0-.782 0v3.032a1.759 1.819 0 0 1-3.517 0V26.27a5.689 5.885 0 0 1 1.678-4.19zm4.966-.927a.782.809 0 0 0 1.563 0v-1.213a.782.809 0 0 0-1.563 0zm1.563 8.691a.977 1.011 0 1 0 1.95-.118 2.42 2.504 0 0 0-.69-1.422.387.401 0 0 0-.566 0 2.33 2.41 0 0 0-.693 1.54z" fill="#c4a2fc"/><path d="M14.988 15.596l5.529-5.721V8.218a2.345 2.426 0 0 1 4.689 0v2.975l5.586 5.778a1.174 1.215 0 0 1 0 1.715l-6.409 6.63a1.174 1.215 0 0 1-1.658 0l-7.738-8.004a1.172 1.213 0 0 1 .001-1.715zm9.437-7.378a1.563 1.617 0 0 0-3.126 0v.849l.098-.101a1.2 1.241 0 0 1 1.658 0l1.37 1.419zm-.346 2.951l-1.055 1.091 4.533 4.691 1.086-1.061zm-8.536 5.571l7.738 8.004a.391.404 0 0 0 .553 0l6.409-6.63a.391.404 0 0 0 0-.572l-1.046-1.078-1.376 1.347a.391.404 0 0 1-.545-.008l-5.08-5.255a.391.404 0 0 1 0-.572l1.331-1.377-1.024-1.059a.4.414 0 0 0-.553 0l-.651.673v3.74a1.172 1.213 0 1 1-.782 0V11.02l-4.975 5.148a.391.404 0 0 0 0 .572zm5.366-2.054a.391.404 0 1 0 .391.404.391.404 0 0 0-.391-.404z" fill="#151a6a"/></svg>`
                        ) +
                        `') 4 4, auto`;
                } else {
                    setCircleCursor(localColor, localLineWidth);
                }
            } else {
                drawingBoard.style.cursor = 'not-allowed';
                toolbox.style.visibility = "hidden";
            }
        }

        function getComplementaryCursorColor(innerColor) {
            const hsp = Math.sqrt(
                0.299 * (innerColor.r * innerColor.r) +
                0.587 * (innerColor.g * innerColor.g) +
                0.114 * (innerColor.b * innerColor.b)
            );

            if (hsp > 127.5) {
                return {
                    r: 0,
                    g: 0,
                    b: 0
                };
            }

            return {
                r: 255,
                g: 255,
                b: 255
            };
        }

        function setCircleCursor(innerColor, size) {
            const outerColor = getComplementaryCursorColor(innerColor);

            let circleSize = size * scaleUpFactor();
            drawingBoard.style.cursor = `url('data:image/svg+xml;utf8,` +
                encodeURIComponent(
                    `<svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="32" height="32">` +
                    generateSVGCircle(circleSize, innerColor, outerColor) + `</svg>')`
                ) +
                ` ` + (circleSize / 2) + ` ` + (circleSize / 2) + `, auto`;
        }

        function generateSVGCircle(circleSize, innerColor, outerColor) {
            let circleRadius = (circleSize / 2);
            let innerColorCSS = "rgb(" + innerColor.r + "," + innerColor.g + "," + innerColor.b + ")";
            let outerColorCSS = "rgb(" + outerColor.r + "," + outerColor.g + "," + outerColor.b + ")";
            return `<circle cx="` + circleRadius + `" cy="` + circleRadius + `" r="` + circleRadius + `" style="fill: ` + innerColorCSS + `; stroke: ` + outerColorCSS + `;"/>`;
        }

        function startGame() {
            socket.send(JSON.stringify({
                type: "start",
            }));
        }

        function clearCanvasAndSendEvent() {
            if (allowDrawing) {
                //Avoid unnecessary traffic back to us and handle the clear directly.
                clear(context);
                socket.send(JSON.stringify({
                    type: "clear-drawing-board"
                }));
            }
        }

        function sendMessage() {
            //We first check if there's more than 10000 characters and only if
            //there isn't, we check for more than 10000 bytes, as that's
            //potentially slower.
            if (messageInput.value.length > 10000 ||
                (new TextEncoder().encode(messageInput.value)).length > 10000) {
                appendMessage("system-message", '{{.Translation.Get "system"}}',
                    '{{.Translation.Get "message-too-long"}}');
                //We keep the messageInput content, since it could've been
                //something important and we don't want the user having to
                //rewrite it. Instead they can send it via some other means
                //or shorten it a bit.
            } else {
                socket.send(JSON.stringify({
                    type: "message",
                    data: messageInput.value
                }));
                messageInput.value = "";
            }

            // Necessary in order to keep the page from submitting.
            return false;
        }

        function chooseWord(index) {
            socket.send(JSON.stringify({
                type: "choose-word",
                data: index
            }));
            allowDrawing = true;
            updateCursor();
            wordDialog.style.visibility = "hidden";
        }

        function onVotekickPlayer(playerId) {
            socket.send(JSON.stringify({
                type: "kick-vote",
                data: playerId
            }));
            hideKickDialog();
        }

        //This automatically scrolls down the chat on arrivals of new messages
        new MutationObserver(() => messageContainer.scrollTop = messageContainer.scrollHeight)
            .observe(messageContainer, {
                attributes: false,
                childList: true,
                subtree: false
            });

        let ownID, ownerID, ownName, drawerID, drawerName;
        let round = 0;
        let rounds = 0;
        let roundEndTime = 0;
        let gameState = "unstarted";
        let votekickEnabled;

        function registerMessageHandler(targetSocket) {
            targetSocket.onmessage = event => {
                let parsed = JSON.parse(event.data);
                if (parsed.type === "ready") {
                    handleReadyEvent(parsed.data);
                } else if (parsed.type === "game-over") {
                    let ready = parsed.data;
                    showRoundEndMessage(ready.previousWord);
                    handleReadyEvent(ready);
                } else if (parsed.type === "update-players") {
                    applyPlayers(parsed.data);
                } else if (parsed.type === "name-change") {
                    const playernameSpan = document.getElementById("playername-" + parsed.data.playerId);
                    const playerImgSpan = document.getElementById("playerimg-" + parsed.data.playerId);
                    if (playernameSpan !== null) {
                        playernameSpan.innerText = parsed.data.playerName;
                    }

                    if (playerImgSpan !== null) {
                        playerImgSpan.setAttribute("src", parsed.data.playerImg);
                    }

                    if (parsed.data.playerId === ownID) {
                        setUsernameLocally(parsed.data.playerName);
                    }
                    if (parsed.data.playerId === drawerID) {
                        waitChooseDrawerSpan.innerText = parsed.data.playerName;
                    }
                } else if (parsed.type === "correct-guess") {
                    playWav('{{.RootPath}}/resources/plop.wav');

                    if (parsed.data === ownID) {
                        appendMessage("correct-guess-message", null, '{{.Translation.Get "correct-guess"}}');
                    } else {
                        for (let i = 0; i < cachedPlayers.length; i++) {
                            let player = cachedPlayers[i];
                            if (player.id === parsed.data) {
                                appendMessage("correct-guess-message", null, '{{.Translation.Get "correct-guess-other-player"}}'.format(player.name));
                                break;
                            }
                        }
                    }
                } else if (parsed.type === "close-guess") {
                    appendMessage("close-guess-message", null, '{{.Translation.Get "close-guess"}}'.format(parsed.data));
                } else if (parsed.type === "update-wordhint") {
                    // this event is (also) sent if the drawer has choosen a word, so we can hide the waitChooseDialog
                    waitChooseDialog.style.visibility = "hidden";
                    applyWordHints(parsed.data);
                } else if (parsed.type === "message") {
                    appendMessage(null, parsed.data.author, parsed.data.content);
                    displayMessageTooltip(parsed.data.authorId, parsed.data.content);
                } else if (parsed.type === "system-message") {
                    appendMessage("system-message", '{{.Translation.Get "system"}}', parsed.data);
                } else if (parsed.type === "non-guessing-player-message") {
                    appendMessage("non-guessing-player-message", parsed.data.author, parsed.data.content);
                } else if (parsed.type === "line") {
                    drawLine(context, parsed.data.fromX * scaleDownFactor(), parsed.data.fromY * scaleDownFactor(), parsed.data.toX * scaleDownFactor(), parsed.data.toY * scaleDownFactor(), parsed.data.color, parsed.data.lineWidth * scaleDownFactor());
                } else if (parsed.type === "fill") {
                    context.fillFlood(parsed.data.x * scaleDownFactor(), parsed.data.y * scaleDownFactor(), parsed.data.color);
                } else if (parsed.type === "clear-drawing-board") {
                    clear(context);
                } else if (parsed.type === "next-turn") {
                    setRoundEndTime(parsed.data.roundEndTime);

                    //As soon as a turn starts, the round should be ongoing, so we make
                    //sure that all types of dialogs, that indicate the game isn't
                    //ongoing, are not visible anymore.
                    unstartedDialog.style.visibility = "hidden";
                    startDialog.style.visibility = "hidden";
                    restartButton.style.display = "none";
                    gameOverDialog.style.visibility = "hidden";

                    //If a player doesn't choose, the dialog will still be up.
                    wordDialog.style.visibility = "hidden";
                    playWav('{{.RootPath}}/resources/end-turn.wav');

                    clear(context);

                    round = parsed.data.round;
                    updateRoundsDisplay();
                    applyPlayers(parsed.data.players);

                    //Show additional dialog, that another user (drawer) is choosing a word
                    waitChooseDrawerSpan.innerText = drawerName;
                    waitChooseDialog.style.visibility = "visible";

                    //We clear this, since there's no word chosen right now.
                    wordContainer.innerHTML = "";

                    allowDrawing = false;
                    updateCursor();

                    if (gameState === "ongoing") {
                        //The previous turn has ended.
                        showRoundEndMessage(parsed.data.previousWord);
                    } else {
                        //First turn, the game starts
                        gameState = "ongoing";
                    }
                } else if (parsed.type === "your-turn") {
                    playWav('{{.RootPath}}/resources/your-turn.wav');
                    waitChooseDialog.style.visibility = "hidden";
                    promptWords(parsed.data[0], parsed.data[1], parsed.data[2]);
                } else if (parsed.type === "drawing") {
                    applyDrawData(parsed.data);
                } else if (parsed.type === "kick-vote") {
                    if (parsed.data.playerId === ownID && parsed.data.voteCount >= parsed.data.requiredVoteCount) {
                        alert('{{.Translation.Get "self-kicked"}}');
                        document.location.href = "{{.RootPath}}/";
                    } else {
                        let kickMessage = '{{.Translation.Get "kick-vote"}}'.format(parsed.data.voteCount, parsed.data.requiredVoteCount, parsed.data.playerName);
                        if (parsed.data.voteCount >= parsed.data.requiredVoteCount) {
                            kickMessage += ' {{.Translation.Get "player-kicked"}}';
                        }
                        appendMessage("system-message", '{{.Translation.Get "system"}}', kickMessage);
                    }
                } else if (parsed.type === "owner-change") {
                    ownerID = parsed.data.playerId;
                    updateButtonVisibilities();
                    appendMessage("system-message", '{{.Translation.Get "system"}}', '{{.Translation.Get "owner-change"}}'.format(parsed.data.playerName));
                } else if (parsed.type === "drawer-kicked") {
                    appendMessage("system-message", '{{.Translation.Get "system"}}', '{{.Translation.Get "drawer-kicked"}}');
                } else if (parsed.type === "lobby-settings-changed") {
                    votekickEnabled = parsed.data.enableVotekick;
                    rounds = parsed.data.rounds;
                    updateRoundsDisplay();
                    updateButtonVisibilities();
                    appendMessage("system-message", '{{.Translation.Get "system"}}', '{{.Translation.Get "lobby-settings-changed"}}\n\n' +
                        '{{.Translation.Get "drawing-time-setting"}}: ' + parsed.data.drawingTime + "\n" +
                        '{{.Translation.Get "rounds-setting"}}: ' + parsed.data.rounds + "\n" +
                        '{{.Translation.Get "public-lobby-setting"}}: ' + parsed.data.public + "\n" +
                        '{{.Translation.Get "enable-votekick-setting"}}: ' + parsed.data.enableVotekick + "\n" +
                        '{{.Translation.Get "max-players-setting"}}: ' + parsed.data.maxPlayers + "\n" +
                        '{{.Translation.Get "custom-words-chance-setting"}}: ' + parsed.data.customWordsChance + "%\n" +
                        '{{.Translation.Get "players-per-ip-limit-setting"}}: ' + parsed.data.clientsPerIpLimit);
                } else if (parsed.type === "shutdown") {
                    socket.onclose = null;
                    socket.close();
                    showDialog("shutdown-info", "Server shutting down",
                        document.createTextNode("Sorry, but the server is about to shut down. Please come back at a later time."));
                }
            }
        };

        function showRoundEndMessage(previousWord) {
            if (previousWord === "") {
                appendMessage("system-message", null, '{{.Translation.Get "round-over"}}');
            } else {
                appendMessage("system-message", null, '{{.Translation.Get "round-over-no-word"}}'.format(previousWord));
            }
        }

        function getPlayer(playerID) {
            for (let i = 0; i < cachedPlayers.length; i++) {
                let player = cachedPlayers[i];
                if (player.id === playerID) {
                    return player;
                }
            }

            return null;
        }

        //In the initial implementation we used a timestamp to know when
        //the round will end. The problem with that approach was that the
        //clock on client and server was often not in sync. The second
        //approach was to instead send milliseconds left and keep counting
        //them down each 500 milliseconds. The problem with this approach, was
        //that there could potentially be timing mistakes while counting down.
        //What we do instead is use our local date, add the timeLeft to it and
        //repeatdly recaculate the timeLeft using the roundEndTime and the
        //current time. This way we won't have any calculation errors.
        //
        //FIXME The only leftover issue is that ping isn't taken into
        //account, however, that's no biggie for now.
        function setRoundEndTime(timeLeftMs) {
            roundEndTime = Date.now() + timeLeftMs;
        }

        function handleReadyEvent(ready) {
            setRoundEndTime(ready.roundEndTime);
            ownerID = ready.ownerId;
            setUsernameLocally(ready.playerName);
            allowDrawing = ready.allowDrawing;
            ownID = ready.playerId;
            round = ready.round;
            rounds = ready.rounds;
            gameState = ready.gameState;
            votekickEnabled = ready.votekickEnabled;
            updateRoundsDisplay();
            updateButtonVisibilities();

            if (ready.players && ready.players.length) {
                applyPlayers(ready.players);
            }
            if (ready.currentDrawing && ready.currentDrawing.length) {
                applyDrawData(ready.currentDrawing);
            }
            if (ready.wordHints && ready.wordHints.length) {
                applyWordHints(ready.wordHints);
            }
            updateCursor();

            if (ready.gameState === "unstarted") {
                if (ownerID === ownID) {
                    startDialog.style.visibility = "visible";
                } else {
                    unstartedDialog.style.visibility = "visible";
                }
            } else if (ready.gameState === "gameOver") {
                gameOverDialog.style.visibility = "visible";
                if (ownerID === ownID) {
                    restartButton.style.display = "inline-block";
                }

                gameOverScoreboard.innerHTML = "";

                //Copying array so we can sort.
                let players = cachedPlayers.slice();
                players.sort((a, b) => {
                    return a.rank - b.rank;
                });

                //Show at least 2 players, but up to 5.
                const maxScoreboardSize = 3;

                for (let i = 0; i < players.length; i++) {
                    let player = players[i];
                    if (!player.connected) {
                        continue;
                    }

                    const isSelf = player.id === ownID;

                    //Even if we don't want to show a player-entry, we still need to iterate
                    //over all players to handle the dialog titles.
                    if (player.rank <= maxScoreboardSize) {
                        let newScoreboardEntry = document.createElement("div");
                        newScoreboardEntry.classList.add("gameover-scoreboard-entry", "p-1");
                        if (isSelf) {
                            newScoreboardEntry.classList.add("gameover-scoreboard-entry-self");
                        }

                        let playerCharacter = document.createElement("div");
                        playerCharacter.classList.add("col-12");
                        let playerCharacterImg = document.createElement("img");
                        playerCharacterImg.classList.add("img-fluid", "player-character");
                        let playerCharacterImgSrc = "{{.RootPath}}" + player.displayImage;
                        playerCharacterImg.setAttribute("src", playerCharacterImgSrc);
                        playerCharacterImg.setAttribute("alt", "Character");
                        playerCharacter.appendChild(playerCharacterImg);

                        let scoreboardRankDiv = document.createElement("div");
                        scoreboardRankDiv.classList.add("col-12");
                        let scoreBoardRank = document.createElement("h5");

                        scoreBoardRank.innerText = "#" + player.rank + " ";

                        if (player.rank === 1) {
                            scoreBoardRank.classList.add("text-warning");
                        }

                        let scoreBoardPlayerName = document.createElement("h6");
                        scoreBoardPlayerName.classList.add("playername");
                        scoreBoardPlayerName.innerText = player.name;

                        scoreboardRankDiv.appendChild(scoreBoardRank);
                        scoreboardRankDiv.appendChild(scoreBoardPlayerName);

                        newScoreboardEntry.appendChild(playerCharacter);
                        newScoreboardEntry.appendChild(scoreboardRankDiv);


                        gameOverScoreboard.appendChild(newScoreboardEntry);
                    }

                    if (isSelf) {
                        if (player.rank === 1) {
                            if ((i + 1 < players.length && players[i + 1].rank === 1) || (i !== 0 && players[0].rank === 1)) {
                                gameOverDialogTitle.innerText = '{{.Translation.Get "game-over-tie"}}';
                            } else {
                                gameOverDialogTitle.innerText = '{{.Translation.Get "game-over-win"}}';
                            }
                        } else {

                            gameOverDialogTitle.innerText = '{{.Translation.Get "game-over"}}'.format(player.rank, player.score);
                        }
                    }
                }
            } else if (ready.gameState === "ongoing") {
                // The wordHints are empty if the round is not started (no word choosen)
                if (ready.wordHints === null) {
                    for (let i = 0; i < ready.players.length; i++) {
                        let player = ready.players[i];

                        // check if the actual player is not drawing
                        if ((player.id === ownID) && (player.state != "drawing")) {
                            //Show additional dialog, that another user (drawer) is choosing a word
                            waitChooseDrawerSpan.innerText = drawerName;
                            waitChooseDialog.style.visibility = "visible";
                            break;
                        }
                    }
                }
            }
        }

        function updateButtonVisibilities() {
            if (votekickEnabled) {
                kickButton.style.display = "initial";
            } else {
                kickButton.style.display = "none";
            }
        }

        function promptWords(wordOne, wordTwo, wordThree) {
            wordButtonZero.textContent = wordOne;
            wordButtonOne.textContent = wordTwo;
            wordButtonTwo.textContent = wordThree;
            wordDialog.style.visibility = "visible";
        }

        function playWav(file) {
            if (sound) {
                let audio = new Audio(file);
                audio.type = 'audio/wav';
                audio.play();
            }
        }

        window.setInterval(() => {
            if (gameState === "ongoing") {
                const msLeft = roundEndTime - Date.now();
                const secondsLeft = Math.max(0, Math.floor(msLeft / 1000));
                timeLeftValue.innerText = "" + secondsLeft
            } else {
                timeLeftValue.innerText = "âˆž";
            }
        }, 500);

        function displayMessageTooltip(id, message) {
            let spanid = "playerimg-" + id;

            let playerRow = document.getElementById(spanid);

            var x = window.matchMedia("(max-width: 768px)");

            if (x.matches) { // If media query matches
                playerRow.setAttribute("data-bs-placement", "bottom");
            } else {
                playerRow.setAttribute("data-bs-placement", "right");
            }

            playerRow.setAttribute("title", message);
            var tooltip = new bootstrap.Tooltip(playerRow);
            tooltip.show();

            setTimeout(
                function() {
                    tooltip.dispose();
                }, 3000);

        }

        //appendMessage adds a new message to the message container. If the
        //message amount is too high, we cut off a part of the messages to
        //prevent lagging and useless memory usage.
        function appendMessage(styleClass, author, message) {
            if (messageContainer.childElementCount >= 100) {
                messageContainer.removeChild(messageContainer.firstChild);
            }

            let newMessageDiv = document.createElement("div");
            newMessageDiv.classList.add("message");
            if (styleClass !== null && styleClass !== "") {
                newMessageDiv.classList.add(styleClass);
            }

            if (author !== null && author !== "") {
                let authorNameSpan = document.createElement("span");
                authorNameSpan.classList.add("chat-name");
                authorNameSpan.innerText = author;
                newMessageDiv.appendChild(authorNameSpan);
            }

            let messageSpan = document.createElement("span");
            messageSpan.classList.add("message-content");
            messageSpan.innerText = message;
            newMessageDiv.appendChild(messageSpan);

            messageContainer.appendChild(newMessageDiv);
        }

        let cachedPlayers;

        function applyPlayers(players) {
            playerContainer.innerHTML = "";
            cachedPlayers = players;
            players.forEach(player => {
                //We don't wanna show the disconnected players.
                if (!player.connected) {
                    return;
                }

                let playerDiv = document.createElement("div");
                playerDiv.classList.add("player-container");

                let playerDataRow = document.createElement("div");
                playerDataRow.classList.add("row", "p-2");

                let playerRank = document.createElement("div");
                playerRank.classList.add("col-12", "col-md-3", "order-2", "order-md-1");

                let playerRankContainer = document.createElement("h4");
                let playerRankValue = document.createElement("span");
                playerRankValue.classList.add("rank");
                playerRankValue.innerText = player.rank;


                playerRankContainer.innerText = "# ";
                playerRankContainer.appendChild(playerRankValue);

                playerRank.appendChild(playerRankContainer);


                let playerDetails = document.createElement("div");
                playerDetails.classList.add("col-12", "col-md-5", "order-3", "order-md-2");

                let playerName = document.createElement("h6");
                playerName.id = "playername-" + player.id;
                playerName.classList.add("playername");
                playerName.innerText = player.name;

                if (player.id === ownID) {
                    playerName.classList.add("playername-self");
                    let tmpTitle = '{{.Translation.Get "change-your-name"}}';
                    playerDiv.setAttribute("title", tmpTitle);
                    playerDiv.setAttribute("data-bs-toggle", "modal");
                    playerDiv.setAttribute("data-bs-target", "#namechange-dialog");
                    playerDiv.setAttribute("style", "cursor:pointer;");

                } else {

                }

                playerDetails.appendChild(playerName);
                let playerPoints = document.createElement("h6");
                playerPoints.innerText = "Points: " + player.score;
                playerDetails.appendChild(playerPoints);


                let playerCharacter = document.createElement("div");
                playerCharacter.classList.add("col-12", "col-md-4", "order-1", "order-md-3");

                let playerCharacterImg = document.createElement("img");

                playerCharacterImg.id = "playerimg-" + player.id;
                playerCharacterImg.setAttribute("data-bs-toggle", "tooltip");
                playerCharacterImg.setAttribute("data-bs-placement", "right");
                playerCharacterImg.setAttribute("title", "message");

                playerCharacterImg.classList.add("img-fluid", "player-character");
                let playerCharacterImgSrc = "{{.RootPath}}" + player.displayImage;
                playerCharacterImg.setAttribute("src", playerCharacterImgSrc);
                playerCharacterImg.setAttribute("alt", "Character");

                playerCharacter.appendChild(playerCharacterImg);

                playerDataRow.appendChild(playerRank);
                playerDataRow.appendChild(playerDetails);
                playerDataRow.appendChild(playerCharacter);

                playerDiv.appendChild(playerDataRow);


                if (player.state === "drawing") {
                    drawerID = player.id;
                    drawerName = player.name;
                    playerDiv.classList.add("active-player");
                }


                playerContainer.appendChild(playerDiv);
            });
        }

        function updateRoundsDisplay() {
            roundSpan.innerText = round;
            maxRoundSpan.innerText = rounds;
        }

        function applyWordHints(wordHints) {
            wordContainer.innerHTML = "";
            wordHints.forEach(hint => {
                let hintSpan = document.createElement("span");
                hintSpan.classList.add("guess-letter");
                if (hint.character === 0) {
                    hintSpan.classList.add("guess-letter-underline");
                    hintSpan.innerHTML = "&nbsp;";
                } else {
                    if (hint.underline) {
                        hintSpan.classList.add("guess-letter-underline");
                    }
                    hintSpan.innerText = String.fromCharCode(hint.character);
                }

                wordContainer.appendChild(hintSpan);
            });
        }

        function applyDrawData(drawElements) {
            clear(context);
            drawElements
                .forEach(drawElement => {
                    let drawData = drawElement.data;
                    if (drawElement.type === "fill") {
                        context.fillFlood(drawData.x * scaleDownFactor(), drawData.y * scaleDownFactor(), drawData.color);
                    } else if (drawElement.type === "line") {
                        drawLine(context, drawData.fromX * scaleDownFactor(),
                            drawData.fromY * scaleDownFactor(), drawData.toX * scaleDownFactor(),
                            drawData.toY * scaleDownFactor(), drawData.color, drawData.lineWidth * scaleDownFactor());
                    } else {
                        console.log("Unknown draw element type: " + drawData.type);
                    }
                });
        }

        let lastX = 0;
        let lastY = 0;

        let touchID = null;

        function onTouchStart(event) {
            //We only allow a single touch
            if (allowDrawing && touchID == null && localTool !== fillBucket) {
                const touch = event.touches[0];
                touchID = touch.identifier;

                // calculate the offset coordinates based on client touch position and drawing board client origin
                const clientRect = drawingBoard.getBoundingClientRect();
                lastX = (touch.clientX - clientRect.left);
                lastY = (touch.clientY - clientRect.top);
            }
        }

        function onTouchMove(event) {
            // Prevent moving, scrolling or zooming the page
            event.preventDefault();

            if (allowDrawing) {
                for (let i = event.changedTouches.length - 1; i >= 0; i--) {
                    if (event.changedTouches[i].identifier === touchID) {
                        const touch = event.changedTouches[i];

                        // calculate the offset coordinates based on client touch position and drawing board client origin
                        const clientRect = drawingBoard.getBoundingClientRect();
                        const offsetX = (touch.clientX - clientRect.left);
                        const offsetY = (touch.clientY - clientRect.top);

                        // drawing functions must check for context boundaries
                        drawLineAndSendEvent(context, lastX, lastY, offsetX, offsetY, localColor, localLineWidth);
                        lastX = offsetX;
                        lastY = offsetY;

                        return;
                    }
                }
            }
        }

        function onTouchEnd(event) {
            for (let i = event.changedTouches.length - 1; i >= 0; i--) {
                if (event.changedTouches[i].identifier === touchID) {
                    touchID = null;
                    return;
                }
            }
        }

        drawingBoard.addEventListener('touchend', onTouchEnd);
        drawingBoard.addEventListener('touchcancel', onTouchEnd);
        drawingBoard.addEventListener('touchstart', onTouchStart);
        drawingBoard.addEventListener('touchmove', onTouchMove);

        function onMouseDown(event) {
            if (allowDrawing && event.buttons === 1 && localTool !== fillBucket) {
                const clientRect = drawingBoard.getBoundingClientRect();
                lastX = event.clientX - clientRect.left;
                lastY = event.clientY - clientRect.top;
            }
        }

        function onMouseMove(event) {
            //event.button === 0 could be wrong, as it can also be the uninitialized state.
            //Therefore we use event.buttons, which works differently.
            if (allowDrawing && event.buttons === 1 && localTool !== fillBucket) {
                // calculate the offset coordinates based on client mouse position and drawing board client origin
                const clientRect = drawingBoard.getBoundingClientRect();
                const offsetX = (event.clientX - clientRect.left);
                const offsetY = (event.clientY - clientRect.top);

                // drawing functions must check for context boundaries
                drawLineAndSendEvent(context, lastX, lastY, offsetX, offsetY, localColor, localLineWidth);
                lastX = offsetX;
                lastY = offsetY;
            }
        }

        function onMouseClick(event) {
            //event.buttons won't work here, since it's always 0. Since we
            //have a click event, we can be sure that we actually had a button
            //clicked and 0 won't be the uninitialized state.
            if (allowDrawing && event.button === 0) {
                if (localTool === fillBucket) {
                    fillAndSendEvent(context, event.offsetX, event.offsetY, localColor);
                } else {
                    drawLineAndSendEvent(context, event.offsetX, event.offsetY,
                        event.offsetX, event.offsetY, localColor, localLineWidth);
                }
            }
        }

        drawingBoard.addEventListener('mousedown', onMouseDown)
        drawingBoard.addEventListener('mousemove', onMouseMove);
        drawingBoard.addEventListener('mouseleave', onMouseMove);
        drawingBoard.addEventListener('click', onMouseClick);

        function onGlobalMouseMove(event) {
            const clientRect = drawingBoard.getBoundingClientRect();
            lastX = Math.min(clientRect.width - 1, Math.max(0, event.clientX - clientRect.left));
            lastY = Math.min(clientRect.height - 1, Math.max(0, event.clientY - clientRect.top));
        }

        //necessary for mousemove to not use the previous exit coordinates.
        //If this is done via mouseleave and mouseenter of the
        //drawingBoard, the lines will end too early on leave and start
        //too late on exit.
        window.addEventListener('mousemove', onGlobalMouseMove);

        function isAnyDialogVisible() {
            for (let i = 0; i < centerDialogs.children.length; i++) {
                if (centerDialogs.children[i].style.visibility === "visible") {
                    return true;
                }
            }

            return false;
        }

        function onKeyDown(event) {
            //Avoid firing actions if the user is in the chat.
            if (document.activeElement instanceof HTMLInputElement) {
                return;
            }

            //If dialogs are open, it doesn't really make sense to be able to
            //change tools. As this is like being in the pause menu of a game.
            if (isAnyDialogVisible()) {
                return;
            }

            //They key choice was made like this, since it's easy to remember
            //and easy to reach. This is how many MOBAs do it and I personally
            //find it better than having to find specific keys on your
            //keyboard. Especially for people that aren't used to typing
            //without looking at their keyboard, this might help.
            if (event.key === "q") {
                toolButtonPen.click();
                chooseTool(pen);
            } else if (event.key === "w") {
                toolButtonFill.click();
                chooseTool(fillBucket);
            } else if (event.key === "e") {
                toolButtonRubber.click();
                chooseTool(rubber);
            }
        }

        //Handling events on the canvas directly isn't possible, since the user
        //must've clicked it at least once in order for that to work.
        window.addEventListener("keydown", onKeyDown);

        function handleCanvasResize() {
            if (drawingBoard.width === drawingBoard.clientWidth && drawingBoard.height === drawingBoard.clientHeight) {
                return false;
            }

            drawingBoard.width = drawingBoard.clientWidth;
            drawingBoard.height = drawingBoard.clientHeight;
            setLineWidth(localLineWidthUnscaled);

            chat.style.maxHeight = drawingBoard.clientHeight + "px";

            return true;
        }

        //Call intially to correct initial state
        handleCanvasResize();

        window.addEventListener("resize", () => {
            if (handleCanvasResize()) {
                //Since the canvas gets cleared, we request the drawing again.
                //Saving it locally would be wasteful and might slow down some
                //clients due to a lot of memory allocation.
                socket.send(JSON.stringify({
                    type: "request-drawing",
                }));
            }
        }, false);


        function clear(context) {
            context.fillStyle = "#FFFFFF";
            context.fillRect(0, 0, drawingBoard.width, drawingBoard.height);
        }

        function fillAndSendEvent(context, x, y, color) {
            if (context.fillFlood(x, y, color)) {
                let fillInstruction = {
                    type: "fill",
                    data: {
                        x: scaelUpAndPrepareFloatForServer(x),
                        y: scaelUpAndPrepareFloatForServer(y),
                        color: color
                    },
                };
                socket.send(JSON.stringify(fillInstruction));
            }
        }

        function drawLineAndSendEvent(context, x1, y1, x2, y2, color, lineWidth) {
            if (localTool === rubber) {
                color = rubberColor;
            }

            drawLine(context, x1, y1, x2, y2, color, lineWidth);

            let drawInstruction = {
                type: "line",
                data: {
                    fromX: scaelUpAndPrepareFloatForServer(x1),
                    fromY: scaelUpAndPrepareFloatForServer(y1),
                    toX: scaelUpAndPrepareFloatForServer(x2),
                    toY: scaelUpAndPrepareFloatForServer(y2),
                    color: color,
                    lineWidth: scaelUpAndPrepareFloatForServer(lineWidth),
                }
            };
            socket.send(JSON.stringify(drawInstruction));
        }

        function drawLine(context, x1, y1, x2, y2, color, lineWidth) {
            // the coordinates must be whole numbers to improve performance.
            // also, decimals as coordinates is not making sense.
            x1 = Math.floor(x1);
            y1 = Math.floor(y1);
            x2 = Math.floor(x2);
            y2 = Math.floor(y2);
            lineWidth = Math.ceil(lineWidth);

            // calculate bounding box
            let left = Math.max(0, Math.min(context.canvas.width, Math.min(x1, x2) - lineWidth));
            let top = Math.max(0, Math.min(context.canvas.height, Math.min(y1, y2) - lineWidth));
            let right = Math.max(0, Math.min(context.canvas.width, Math.max(x1, x2) + lineWidth));
            let bottom = Math.max(0, Math.min(context.canvas.height, Math.max(y1, y2) + lineWidth));

            // off canvas, so don't draw anything
            if (right - left === 0 || bottom - top === 0) {
                return;
            }

            const circleMap = generateCircleMap(Math.floor(lineWidth / 2));
            const offset = Math.floor(circleMap.length / 2);
            const imageData = context.getImageData(left, top, right - left, bottom - top);

            for (let ix = 0; ix < circleMap.length; ix++) {
                for (let iy = 0; iy < circleMap[ix].length; iy++) {
                    if (circleMap[ix][iy] === 1 || (x1 === x2 && y1 === y2 && circleMap[ix][iy] === 2)) {
                        const newX1 = x1 + ix - offset - left;
                        const newY1 = y1 + iy - offset - top;
                        const newX2 = x2 + ix - offset - left;
                        const newY2 = y2 + iy - offset - top;
                        drawBresenhamLine(imageData, newX1, newY1, newX2, newY2, color);
                    }
                }
            }
            context.putImageData(imageData, left, top);
        }

        function drawBresenhamLine(imageData, x1, y1, x2, y2, color) {
            const dx = Math.abs(x2 - x1);
            const dy = Math.abs(y2 - y1);
            const sx = (x1 < x2) ? 1 : -1;
            const sy = (y1 < y2) ? 1 : -1;
            let err = dx - dy;

            while (true) {
                //check if pixel is inside the canvas
                if (!(x1 < 0 || x1 >= imageData.width || y1 < 0 || y1 >= imageData.height)) {
                    setPixel(imageData, x1, y1, color);
                }

                if ((x1 === x2) && (y1 === y2)) break;
                const e2 = 2 * err;
                if (e2 > -dy) {
                    err -= dy;
                    x1 += sx;
                }
                if (e2 < dx) {
                    err += dx;
                    y1 += sy;
                }
            }
        }

        function generateCircleMap(radius) {
            const diameter = 2 * radius;
            let circleData = new Array(diameter);

            for (let x = 0; x < diameter; x++) {
                circleData[x] = new Array(diameter);
                for (let y = 0; y < diameter; y++) {
                    const distanceToRadius = Math.sqrt(Math.pow(radius - x, 2) + Math.pow(radius - y, 2));
                    if (distanceToRadius > radius) {
                        circleData[x][y] = 0;
                    } else if (distanceToRadius < radius - 2) {
                        circleData[x][y] = 2;
                    } else {
                        circleData[x][y] = 1;
                    }
                }
            }

            return circleData;
        }

        function setPixel(imageData, x, y, color) {
            const offset = (y * imageData.width + x) * 4;
            imageData.data[offset] = color.r;
            imageData.data[offset + 1] = color.g;
            imageData.data[offset + 2] = color.b;
            //We never want transparency, therefore alpha is always 255.
            imageData.data[offset + 3] = 255;
        }

    </script>

</body>

</html>
{{end}}
